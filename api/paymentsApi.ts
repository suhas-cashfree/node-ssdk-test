/**
 * Cashfree Payment Gateway APIs
 * Cashfree\'s Payment Gateway APIs provide developers with a streamlined pathway to integrate advanced payment processing capabilities into their applications, platforms and websites.
 *
 * The version of the OpenAPI document: 1.0.4
 * Contact: developers@cashfree.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { ApiError } from '../model/apiError';
import { ApiError404 } from '../model/apiError404';
import { ApiError409 } from '../model/apiError409';
import { ApiError502 } from '../model/apiError502';
import { AuthenticationError } from '../model/authenticationError';
import { AuthorizationRequest } from '../model/authorizationRequest';
import { BadRequestError } from '../model/badRequestError';
import { IdempotencyError } from '../model/idempotencyError';
import { OTPRequest } from '../model/oTPRequest';
import { OTPResponseEntity } from '../model/oTPResponseEntity';
import { OrderPayRequest } from '../model/orderPayRequest';
import { OrderPayResponse } from '../model/orderPayResponse';
import { PaymentsEntity } from '../model/paymentsEntity';
import { RateLimitError } from '../model/rateLimitError';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://sandbox.cashfree.com/pg';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum PaymentsApiApiKeys {
    XClientID,
    XClientSecret,
    XClientSignatureHeader,
    XPartnerAPIKey,
    XPartnerMerchantID,
}

export class PaymentsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'XClientID': new ApiKeyAuth('header', 'x-client-id'),
        'XClientSecret': new ApiKeyAuth('header', 'x-client-secret'),
        'XClientSignatureHeader': new ApiKeyAuth('header', 'x-client-signature'),
        'XPartnerAPIKey': new ApiKeyAuth('header', 'x-partner-apikey'),
        'XPartnerMerchantID': new ApiKeyAuth('header', 'x-partner-merchantid'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsApiApiKeys, value: string) {
        (this.authentications as any)[PaymentsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Use this API to view payment details of an order for a payment ID.
     * @summary Get Payment by ID
     * @param xApiVersion API version to be used. Format is in YYYY-MM-DD
     * @param orderId The id which uniquely identifies your order
     * @param cfPaymentId The Cashfree payment or transaction ID.
     * @param xRequestId Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     */
    public async getPaymentbyId (xApiVersion: string, orderId: string, cfPaymentId: string, xRequestId?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentsEntity;  }> {
        const localVarPath = this.basePath + '/orders/{order_id}/payments/{cf_payment_id}'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)))
            .replace('{' + 'cf_payment_id' + '}', encodeURIComponent(String(cfPaymentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'xApiVersion' is not null or undefined
        if (xApiVersion === null || xApiVersion === undefined) {
            throw new Error('Required parameter xApiVersion was null or undefined when calling getPaymentbyId.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getPaymentbyId.');
        }

        // verify required parameter 'cfPaymentId' is not null or undefined
        if (cfPaymentId === null || cfPaymentId === undefined) {
            throw new Error('Required parameter cfPaymentId was null or undefined when calling getPaymentbyId.');
        }

        localVarHeaderParams['x-api-version'] = ObjectSerializer.serialize(xApiVersion, "string");
        localVarHeaderParams['x-request-id'] = ObjectSerializer.serialize(xRequestId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.XPartnerAPIKey.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XPartnerAPIKey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientSecret.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientSecret.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XPartnerMerchantID.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XPartnerMerchantID.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientID.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientID.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientSignatureHeader.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientSignatureHeader.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentsEntity;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentsEntity");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Use this API to view all payment details for an order.
     * @summary Get Payments for an Order
     * @param xApiVersion API version to be used. Format is in YYYY-MM-DD
     * @param orderId The id which uniquely identifies your order
     * @param xRequestId Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     */
    public async getPaymentsfororder (xApiVersion: string, orderId: string, xRequestId?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<PaymentsEntity>;  }> {
        const localVarPath = this.basePath + '/orders/{order_id}/payments'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'xApiVersion' is not null or undefined
        if (xApiVersion === null || xApiVersion === undefined) {
            throw new Error('Required parameter xApiVersion was null or undefined when calling getPaymentsfororder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getPaymentsfororder.');
        }

        localVarHeaderParams['x-api-version'] = ObjectSerializer.serialize(xApiVersion, "string");
        localVarHeaderParams['x-request-id'] = ObjectSerializer.serialize(xRequestId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.XPartnerAPIKey.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XPartnerAPIKey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientSecret.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientSecret.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XPartnerMerchantID.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XPartnerMerchantID.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientID.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientID.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientSignatureHeader.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientSignatureHeader.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<PaymentsEntity>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<PaymentsEntity>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * If you accept OTP on your own page, you can use the below API to send OTP to Cashfree.
     * @summary Submit or Resend OTP
     * @param xApiVersion API version to be used. Format is in YYYY-MM-DD
     * @param cfPaymentId The Cashfree payment or transaction ID.
     * @param xRequestId Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param oTPRequest Request body to submit/resend headless OTP. To use this API make sure you have headless OTP enabled for your account
     */
    public async oTPRequest (xApiVersion: string, cfPaymentId: string, xRequestId?: string, oTPRequest?: OTPRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: OTPResponseEntity;  }> {
        const localVarPath = this.basePath + '/orders/pay/authenticate/{cf_payment_id}'
            .replace('{' + 'cf_payment_id' + '}', encodeURIComponent(String(cfPaymentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'xApiVersion' is not null or undefined
        if (xApiVersion === null || xApiVersion === undefined) {
            throw new Error('Required parameter xApiVersion was null or undefined when calling oTPRequest.');
        }

        // verify required parameter 'cfPaymentId' is not null or undefined
        if (cfPaymentId === null || cfPaymentId === undefined) {
            throw new Error('Required parameter cfPaymentId was null or undefined when calling oTPRequest.');
        }

        localVarHeaderParams['x-api-version'] = ObjectSerializer.serialize(xApiVersion, "string");
        localVarHeaderParams['x-request-id'] = ObjectSerializer.serialize(xRequestId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(oTPRequest, "OTPRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: OTPResponseEntity;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "OTPResponseEntity");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Use this API when you have already created the orders and want Cashfree to process the payment. To use this API S2S flag needs to be enabled from the backend. In case you want to use the cards payment option the PCI DSS flag is required, for more information send an email to \"care@cashfree.com\". 
     * @summary Order Pay
     * @param xApiVersion API version to be used. Format is in YYYY-MM-DD
     * @param xRequestId Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param orderPayRequest Request body to create a transaction at cashfree using &#x60;payment_session_id&#x60;
     */
    public async orderPay (xApiVersion: string, xRequestId?: string, orderPayRequest?: OrderPayRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: OrderPayResponse;  }> {
        const localVarPath = this.basePath + '/orders/sessions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'xApiVersion' is not null or undefined
        if (xApiVersion === null || xApiVersion === undefined) {
            throw new Error('Required parameter xApiVersion was null or undefined when calling orderPay.');
        }

        localVarHeaderParams['x-api-version'] = ObjectSerializer.serialize(xApiVersion, "string");
        localVarHeaderParams['x-request-id'] = ObjectSerializer.serialize(xRequestId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(orderPayRequest, "OrderPayRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: OrderPayResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "OrderPayResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Use this API to capture or void a preauthorized payment
     * @summary Preauthorization
     * @param xApiVersion API version to be used. Format is in YYYY-MM-DD
     * @param orderId The id which uniquely identifies your order
     * @param xRequestId Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param xIdempotencyKey Idempotency works by saving the resulting status code and body of the first request made for any given idempotency key, regardless of whether it succeeded or failed. Subsequent requests with the same key return the same result, including 500 errors.  Currently supported on all POST calls that uses x-client-id &amp; x-client-secret. To use enable, pass x-idempotency-key in the request header. The value of this header must be unique to each operation you are trying to do. One example can be to use the same order_id that you pass while creating orders  
     * @param authorizationRequest Request body to capture or void a transaction
     */
    public async preauthorization (xApiVersion: string, orderId: string, xRequestId?: string, xIdempotencyKey?: string, authorizationRequest?: AuthorizationRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentsEntity;  }> {
        const localVarPath = this.basePath + '/orders/{order_id}/authorization'
            .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'xApiVersion' is not null or undefined
        if (xApiVersion === null || xApiVersion === undefined) {
            throw new Error('Required parameter xApiVersion was null or undefined when calling preauthorization.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling preauthorization.');
        }

        localVarHeaderParams['x-api-version'] = ObjectSerializer.serialize(xApiVersion, "string");
        localVarHeaderParams['x-request-id'] = ObjectSerializer.serialize(xRequestId, "string");
        localVarHeaderParams['x-idempotency-key'] = ObjectSerializer.serialize(xIdempotencyKey, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(authorizationRequest, "AuthorizationRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.XPartnerAPIKey.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XPartnerAPIKey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientSecret.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientSecret.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XPartnerMerchantID.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XPartnerMerchantID.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientID.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientID.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientSignatureHeader.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientSignatureHeader.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentsEntity;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentsEntity");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
