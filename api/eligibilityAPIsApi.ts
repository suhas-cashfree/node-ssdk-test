/**
 * Cashfree Payment Gateway APIs
 * Cashfree\'s Payment Gateway APIs provide developers with a streamlined pathway to integrate advanced payment processing capabilities into their applications, platforms and websites.
 *
 * The version of the OpenAPI document: 2022-01-01
 * Contact: developers@cashfree.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { ApiError } from '../model/apiError';
import { ApiError404 } from '../model/apiError404';
import { ApiError409 } from '../model/apiError409';
import { ApiError502 } from '../model/apiError502';
import { AuthenticationError } from '../model/authenticationError';
import { BadRequestError } from '../model/badRequestError';
import { EligibilityCardlessEMIRequest } from '../model/eligibilityCardlessEMIRequest';
import { EligibilityOffersRequest } from '../model/eligibilityOffersRequest';
import { EligibilityPaymentMethodsRequest } from '../model/eligibilityPaymentMethodsRequest';
import { EligibleCardlessEMIEntity } from '../model/eligibleCardlessEMIEntity';
import { EligibleOffersEntity } from '../model/eligibleOffersEntity';
import { EligiblePaylater } from '../model/eligiblePaylater';
import { EligiblePaymentMethodsEntity } from '../model/eligiblePaymentMethodsEntity';
import { IdempotencyError } from '../model/idempotencyError';
import { RateLimitError } from '../model/rateLimitError';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://sandbox.cashfree.com/pg';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum EligibilityAPIsApiApiKeys {
    XClientID,
    XClientSecret,
    XClientSignatureHeader,
    XPartnerAPIKey,
    XPartnerMerchantID,
}

export class EligibilityAPIsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'XClientID': new ApiKeyAuth('header', 'x-client-id'),
        'XClientSecret': new ApiKeyAuth('header', 'x-client-secret'),
        'XClientSignatureHeader': new ApiKeyAuth('header', 'x-client-signature'),
        'XPartnerAPIKey': new ApiKeyAuth('header', 'x-partner-apikey'),
        'XPartnerMerchantID': new ApiKeyAuth('header', 'x-partner-merchantid'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: EligibilityAPIsApiApiKeys, value: string) {
        (this.authentications as any)[EligibilityAPIsApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Use this API to get eligible Cardless EMI Payment Methods for a customer on an order.
     * @summary Get eligible Cardless EMI
     * @param xApiVersion API version to be used. Format is in YYYY-MM-DD
     * @param xRequestId Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param eligibilityCardlessEMIRequest Request body to check for eligibility for cardlessemi
     */
    public async eligibilityCardlessEMI (xApiVersion: string, xRequestId?: string, eligibilityCardlessEMIRequest?: EligibilityCardlessEMIRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<EligibleCardlessEMIEntity>;  }> {
        const localVarPath = this.basePath + '/eligibility/cardlessemi';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'xApiVersion' is not null or undefined
        if (xApiVersion === null || xApiVersion === undefined) {
            throw new Error('Required parameter xApiVersion was null or undefined when calling eligibilityCardlessEMI.');
        }

        localVarHeaderParams['x-api-version'] = ObjectSerializer.serialize(xApiVersion, "string");
        localVarHeaderParams['x-request-id'] = ObjectSerializer.serialize(xRequestId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(eligibilityCardlessEMIRequest, "EligibilityCardlessEMIRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.XPartnerAPIKey.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XPartnerAPIKey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientSecret.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientSecret.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XPartnerMerchantID.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XPartnerMerchantID.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientID.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientID.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientSignatureHeader.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientSignatureHeader.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<EligibleCardlessEMIEntity>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<EligibleCardlessEMIEntity>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Use this API to get eligible offers for an order or amount.
     * @summary Get eligible Offers
     * @param xApiVersion API version to be used. Format is in YYYY-MM-DD
     * @param xRequestId Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param eligibilityOffersRequest Request body to check for eligibility for offers
     */
    public async eligibilityOffer (xApiVersion: string, xRequestId?: string, eligibilityOffersRequest?: EligibilityOffersRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<EligibleOffersEntity>;  }> {
        const localVarPath = this.basePath + '/eligibility/offers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'xApiVersion' is not null or undefined
        if (xApiVersion === null || xApiVersion === undefined) {
            throw new Error('Required parameter xApiVersion was null or undefined when calling eligibilityOffer.');
        }

        localVarHeaderParams['x-api-version'] = ObjectSerializer.serialize(xApiVersion, "string");
        localVarHeaderParams['x-request-id'] = ObjectSerializer.serialize(xRequestId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(eligibilityOffersRequest, "EligibilityOffersRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.XPartnerAPIKey.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XPartnerAPIKey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientSecret.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientSecret.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XPartnerMerchantID.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XPartnerMerchantID.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientID.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientID.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientSignatureHeader.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientSignatureHeader.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<EligibleOffersEntity>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<EligibleOffersEntity>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Use this API to get eligible Paylater Payment Methods for a customer on an order.
     * @summary Get eligible Paylater
     * @param xApiVersion API version to be used. Format is in YYYY-MM-DD
     * @param xRequestId Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param eligibilityCardlessEMIRequest Request body to check for eligibility for paylater
     */
    public async eligibilityPaylater (xApiVersion: string, xRequestId?: string, eligibilityCardlessEMIRequest?: EligibilityCardlessEMIRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<EligiblePaylater>;  }> {
        const localVarPath = this.basePath + '/eligibility/paylater';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'xApiVersion' is not null or undefined
        if (xApiVersion === null || xApiVersion === undefined) {
            throw new Error('Required parameter xApiVersion was null or undefined when calling eligibilityPaylater.');
        }

        localVarHeaderParams['x-api-version'] = ObjectSerializer.serialize(xApiVersion, "string");
        localVarHeaderParams['x-request-id'] = ObjectSerializer.serialize(xRequestId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(eligibilityCardlessEMIRequest, "EligibilityCardlessEMIRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.XPartnerAPIKey.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XPartnerAPIKey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientSecret.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientSecret.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XPartnerMerchantID.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XPartnerMerchantID.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientID.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientID.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientSignatureHeader.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientSignatureHeader.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<EligiblePaylater>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<EligiblePaylater>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Use this API to get eligible Payment Methods
     * @summary Get eligible Payment Methods
     * @param xApiVersion API version to be used. Format is in YYYY-MM-DD
     * @param xRequestId Request id for the API call. Can be used to resolve tech issues. Communicate this in your tech related queries to cashfree
     * @param eligibilityPaymentMethodsRequest Request body to get eligibile payment methods
     */
    public async eligibilityPaymentMethods (xApiVersion: string, xRequestId?: string, eligibilityPaymentMethodsRequest?: EligibilityPaymentMethodsRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Array<EligiblePaymentMethodsEntity>;  }> {
        const localVarPath = this.basePath + '/eligibility/payment_methods';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'xApiVersion' is not null or undefined
        if (xApiVersion === null || xApiVersion === undefined) {
            throw new Error('Required parameter xApiVersion was null or undefined when calling eligibilityPaymentMethods.');
        }

        localVarHeaderParams['x-api-version'] = ObjectSerializer.serialize(xApiVersion, "string");
        localVarHeaderParams['x-request-id'] = ObjectSerializer.serialize(xRequestId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(eligibilityPaymentMethodsRequest, "EligibilityPaymentMethodsRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.XPartnerAPIKey.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XPartnerAPIKey.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientSecret.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientSecret.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XPartnerMerchantID.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XPartnerMerchantID.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientID.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientID.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.XClientSignatureHeader.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.XClientSignatureHeader.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Array<EligiblePaymentMethodsEntity>;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Array<EligiblePaymentMethodsEntity>");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
